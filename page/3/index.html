<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"naoemb.cf","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="naoemb">
<meta property="og:url" content="https://naoemb.cf/page/3/index.html">
<meta property="og:site_name" content="naoemb">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="naoemb">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://naoemb.cf/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>naoemb</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">naoemb</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">65</span></a>

  </li>
        <li class="menu-item menu-item-笔记">

    <a href="/%E7%AC%94%E8%AE%B0" rel="section"><i class="fa fa-sticky-note fa-fw"></i>笔记</a>

  </li>
        <li class="menu-item menu-item-c练习题">

    <a href="/C%E7%BB%83%E4%B9%A0%E9%A2%98/" rel="section"><i class="fa fa-code fa-fw"></i>C练习题</a>

  </li>
        <li class="menu-item menu-item-unix">

    <a href="/UNIX/" rel="section"><i class="fa fa-file-code-o fa-fw"></i>UNIX</a>

  </li>
        <li class="menu-item menu-item-每天英语">

    <a href="/%E6%AF%8F%E5%A4%A9%E8%8B%B1%E8%AF%AD" rel="section"><i class=" fa-fw"></i>每天英语</a>

  </li>
        <li class="menu-item menu-item-musiclist">

    <a href="/musiclist/" rel="section"><i class="fa fa-volume-up fa-fw"></i>歌单</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://naoemb.cf/2023/02/16/embsky/STM32/stm32_04day/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%BE%AE%E4%BF%A1%E5%A4%B4%E5%83%8F.jpg">
      <meta itemprop="name" content="naoemb">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="naoemb">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/16/embsky/STM32/stm32_04day/" class="post-title-link" itemprop="url">stm32_note_04day</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-16 08:03:05" itemprop="dateCreated datePublished" datetime="2023-02-16T08:03:05+08:00">2023-02-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-02 01:54:57" itemprop="dateModified" datetime="2022-09-02T01:54:57+08:00">2022-09-02</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>2022-8-18<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;	</p>
<h1 id="一-温故知新"><a href="#一-温故知新" class="headerlink" title="一.温故知新"></a>一.温故知新</h1><pre><code>    1.通过讲硬件的手册了解芯片内部结构
        CPU使用的是ARM-CORTEX-M3的核心,主频是72MHz
        CPU是通过三总线(数据 地址 控制)来访问外设的
        在STM32中AHB AHB1 AHB2都是三总线叫做高速总线
        在STM32中APB1 APB2也是三总线叫做外设总线
        芯片的管脚是多功能复用型的管脚
    2.GPIO的输出
        驱动LED灯
        选择了操作外设的寄存器的开发方式(需要使用C语言的位运算符)
        寄存器的真实地址 = 基地址 + 偏移地址
        *(volatile unsigned int *)(0x40011000 + 0x0C)
        举一反三
        驱动蜂鸣器
        BEEP	PC7
        管脚输出高电平,蜂鸣器响
        管脚输出低电平,蜂鸣器不响
</code></pre>
<h1 id="二-GPIO的输入"><a href="#二-GPIO的输入" class="headerlink" title="二.GPIO的输入"></a>二.GPIO的输入</h1><pre><code>    输入功能相当于检测,输出功能相当于控制
    输入功能分为
    上拉输入	管脚在没有外设操作的情况下,默认呈现的是高电平的状态
            对于低电平有触发效果
    下拉输入	管脚在没有外设操作的情况下,默认呈现的是低电平的状态
            对于高电平有触发效果
    浮空输入	管脚在没有外设操作的情况下,默认呈现的既不是高也不是低
            会对于外界的影响而变化
        (当在操作串口外设功能时会用到浮空输入)
    驱动开发板上的功能按键
    1.查看开发板原理图
        KEY0	PC9	上拉输入
        KEY1	PC8	上拉输入
        KEY2	PA0	下拉输入
        KEY0 KEY1在没有按下时应当检测到高电平,按下应当检测到低电平
        KEY2在没有按下时应当检测到低电平,按下应当检测到高电平
    2.查看芯片的手册
    #define GPIOC_IDR *(volatile unsigned int *)(GPIOC_BASE + 0x08)
    如何读取第9位的电平高低？
    ret = (GPIOC_IDR &gt;&gt; 9) &amp; 0x01;
    3.写功能按键的驱动程序
    ST的官方固件大部分的参数都是按照位图来定义的
    以位图的形式定义
    GPIOA	0x0001	0001
    GPIOB	0x0002	0010
    GPIOC	0x0004	0100
    GPIOD	0x0008	1000
    GPIOA | GPIOB = 0011
    不是以位图的形式定义
    GPIOA	0x0001	0001
    GPIOB	0x0002	0010
    GPIOC	0x0003	0011
    GPIOD	0x0004	0100
    GPIOA | GPIOB = 0011
</code></pre>
<h1 id="三-换一种开发方式"><a href="#三-换一种开发方式" class="headerlink" title="三.换一种开发方式"></a>三.换一种开发方式</h1><pre><code>    需要调用ST公司的官方固件
    手册是辅助大家开发的,千万不要本末倒置
</code></pre>
<h1 id="四-演示未来的开发方式"><a href="#四-演示未来的开发方式" class="headerlink" title="四.演示未来的开发方式"></a>四.演示未来的开发方式</h1><pre><code>    STM32CUBEMX + Keil

===============================
作业
1.把今天讲过的内容完整的复习一遍
2.把&lt;01test&gt;项目工程拷贝一份,用LIB库实现LED灯、蜂鸣器、功能按键
3.完成需求
    通过3个功能按键,控制3个LED灯(开关)
    当按下抬起KEY0,LED0常亮,当再一次按下抬起KEY0,LED0常灭
    当按下抬起KEY1,LED1常亮,当再一次按下抬起KEY1,LED1常灭
    当按下抬起KEY2,LED2常亮,当再一次按下抬起KEY2,LED2常灭
===============================
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://naoemb.cf/2023/02/16/embsky/STM32/stm32_05day/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%BE%AE%E4%BF%A1%E5%A4%B4%E5%83%8F.jpg">
      <meta itemprop="name" content="naoemb">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="naoemb">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/16/embsky/STM32/stm32_05day/" class="post-title-link" itemprop="url">stm32_note_05day</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-16 08:03:05" itemprop="dateCreated datePublished" datetime="2023-02-16T08:03:05+08:00">2023-02-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-02 01:55:05" itemprop="dateModified" datetime="2022-09-02T01:55:05+08:00">2022-09-02</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>2022-8-19<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<h1 id="一-温故知新"><a href="#一-温故知新" class="headerlink" title="一.温故知新"></a>一.温故知新</h1><pre><code>    1.GPIO的输出实验-&gt;蜂鸣器
    2.GPIO的输入实验-&gt;功能按键
        检测按键是否被按下
        (轮询 和 中断)
    3.更换开发方式-&gt;调用ST公司的LIB库
    4.演示STM32CUBEMX工具的使用
</code></pre>
<h1 id="二-位带-bitband"><a href="#二-位带-bitband" class="headerlink" title="二.位带(bitband)"></a>二.位带(bitband)</h1><pre><code>    位带可以以原子操作的方式操作寄存器中的某些位
    1.引出位带
    ----------------------------------------------------
    例子 : 
    想要把十进制整数100,赋值到0x12345678地址中?
    *(volatile unsigned int *)(0x12345678) = 100;
    一次性操作32bit
    ----------------------------------------------------
    例子:
    想要把0x12345678地址中的第9bit,置1
    *(volatile unsigned int *)(0x12345678) |= (1 &lt;&lt; 9);
    想要把0x12345678地址中的第8bit,清0
    *(volatile unsigned int *)(0x12345678) &amp;= ~(1 &lt;&lt; 8);
    一次操作1bit
    ----------------------------------------------------
    但是上述直接给某一个位赋值的操作,不是原子操作
    原子操作 : 就是不可分割的操作,原子操作在执行结束前,
        不会被任何信号或者任何中断打断
    
    2.介绍位带
    位带并不是C语言提供的,是硬件提供的,并不是STM32芯片提供的,
        而是由ARM-CORTEX-M3的核心提供的
    ----------------------------------------------------
    位带和位域有点类似
    ----------------------------------------------------
    打开&lt;STM32RBT6\DataSheet\ARM-CORTEX-M&gt;目录下
        &lt;Cortex-M3权威指南CnR2（电子书）.pdf&gt;
    P83	查看存储器的映射
    ARM-CORTEX-M3支持访问4Gb的空间大小(物理的空间)
    只有片上SRAM开头的1Mb空间和片上外设的1MB空间支持位带访问
    位带的操作其实
    就是把位带区中的每一位都做一个地址别名,映射到位带别名区
    将来在访问位带别名区的空间时,就相当于是在访问位带区中某一位

    位带区的空间有1M个字节,等于有8M个位,每一位都做一个地址别名映射到
    位带别名区,映射的地址需要以4字节的方式对齐,所以
    位带区的1MB会在位带别名区膨胀成32MB

    虽然片上SRAM和片上外设都支持位带访问,
    但是片上外设的位带操作会用的更多一些(尤其是GPIO的输入与输出)

    3.位带转换的表达式
    可以把位带转换的操作封装成宏函数
#define BITBAND(ADDR, BITNUM)
((ADDR&amp;0xF0000000)+0x2000000+((ADDR&amp;0xFFFFF)&lt;&lt;5)+(BITNUM&lt;&lt;2))

#define MEM_ADDR(ADDR) *(volatile unsigned int *)(ADDR)

#define BIT_BAND(ADDR,BITNUM) MEM_ADDR(BITBAND(ADDR, BITNUM))
                    
#define GPIOA_IDR (GPIOA_BASE + 0x08)
#define GPIOA_ODR (GPIOA_BASE + 0x0C)

#define GPIOB_IDR (GPIOB_BASE + 0x08)
#define GPIOB_ODR (GPIOB_BASE + 0x0C)

#define GPIOC_IDR (GPIOC_BASE + 0x08)
#define GPIOC_ODR (GPIOC_BASE + 0x0C)

#define GPIOD_IDR (GPIOD_BASE + 0x08)
#define GPIOD_ODR (GPIOD_BASE + 0x0C)

#define PAOut(BITNUM) BIT_BAND(GPIOA_ODR, BITNUM)
#define PAIn(BITNUM) BIT_BAND(GPIOA_IDR, BITNUM)

PAOut(9) = 1;//把PA9管脚拉高
PAOut(8) = 0;//把PA8管脚拉低

    ret = PAIn(0);//读取PA0管脚的电平高低

    4.在项目工程中引入位带的操作
    
</code></pre>
<h1 id="三-定时器"><a href="#三-定时器" class="headerlink" title="三.定时器"></a>三.定时器</h1><pre><code>    流水灯的程序中需要使用延时(精确延时 和 粗略延时)
    精确延时需要使用定时器
    无论何种定时器都是由两个因素来决定定时长短的
    时钟频率 和 计数值
计数值	10    10      72000000  72000    72         72 / 1000
时钟频率	1Hz  10Hz  72MHz      72MHz  72MHz  72MHz
定时时间	10s   1s	   1s              1ms       1us       1ns
    1s = 1000ms = 1000000us = 1000000000ns
</code></pre>
<h1 id="四-系统定时器"><a href="#四-系统定时器" class="headerlink" title="四.系统定时器"></a>四.系统定时器</h1><pre><code>    通过最新选型手册可知,在STM32芯片中有非常丰富的定时器资源
    可以分为普通定时器和其他(特殊)定时器
    除了STM32芯片为程序员提供了定时器资源以外,ARM-CORTEX-M3的核心
    也为程序员提供了定时器的资源
    由ARM核心提供的定时器资源叫做系统定时器(system timer | systick)
    1.系统定时器的时钟频率
打开&lt;STM32RBT6\DataSheet\STM32&gt;目录下&lt;STM32F10x中文参考手册.pdf&gt;
P46	
    在STM32芯片中有多个时钟源
    HSI	系统内部的高速时钟	8MHz
    HSE	系统外部的高速时钟	8MHz
    PLL	锁相环(倍频器)	72MHz
    LSI	系统内部的低速时钟	40KHz
    LSE	系统外部的低速时钟	32.768KHz
    系统定时器的时钟频率 = SYSCLK / 8 或者 SYSCLK
    SYSCLK的时钟	可以由	HSI 或者HSE或者PLL提供
    已知HSI和HSE都是8MHz的时钟频率,都不足以达到72MHz
    所以只能是由PLL为SYSCLK提供时钟频率
    PLL是一个锁相环,是一个倍频器,本身是不会产生时钟频率的,
    需要有基础的时钟频率才能进行倍频
    PLL的基础时钟频率	可以由	HSI或者HSE来提供
    默认会选择HSE为PLL提供基础的时钟频率
    芯片外部的晶振产生的时钟频率要比芯片内部自己产生的时钟频率稳定的多

    2.系统定时器的计数值范围
    打开&lt;STM32RBT6\DataSheet\ARM-CORTEX-M&gt;目录下
    &lt;Cortex-M3权威指南CnR2（电子书）.pdf&gt;
    P189	
    控制及状态寄存器
        第0位		开启系统定时器的计数
                0:关闭	1:开启
        第1位		是否触发中断
                0:不触发	1:触发
        第2位		时钟源的选择
                0:外部的	1:内部的
        第3-15位		保留
        第16位		用于判断计数器是否计数到0
        第17-31位		保留
    重装载值寄存器
        第0-23位		用来存放重装载值
        第24-31位		保留
    当前值寄存器
        第0-23位		用来存放当前计数值
        第24-31位		保留
    计数值的范围是[24个0 - 24个1]（0 - 16M-1）

    3.调用官方固件驱动系统定时器
    官方提供的固件有问题
        1)只有开启系统定时器,没有关闭系统定时器
        2)默认开启了中断

==============================
作业
1.把这周讲过的内容完完整整的复习一遍
2.把这周写过的项目工程再重新写一遍
==============================
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://naoemb.cf/2023/02/16/embsky/STM32/stm32_06day/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%BE%AE%E4%BF%A1%E5%A4%B4%E5%83%8F.jpg">
      <meta itemprop="name" content="naoemb">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="naoemb">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/16/embsky/STM32/stm32_06day/" class="post-title-link" itemprop="url">stm32_note_06day</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-16 08:03:05" itemprop="dateCreated datePublished" datetime="2023-02-16T08:03:05+08:00">2023-02-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-02 01:55:10" itemprop="dateModified" datetime="2022-09-02T01:55:10+08:00">2022-09-02</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>2022-8-22<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<h1 id="一-温故知新"><a href="#一-温故知新" class="headerlink" title="一.温故知新"></a>一.温故知新</h1><pre><code>    驱动LED灯、蜂鸣器、功能按键、系统定时器
    直接操作外设寄存器、官方LIB库、官方HAL库
    是由ARM核心支持的位带的操作
    系统定时器(system timer | systick)
    是由ARM核心提供的定时器资源
    决定定时长短是由时钟频率和计数值
    时钟频率是通过时钟树的分析得出的SYSCLK / 8 或者 SYSCLK
    计数值是通过ARM的手册分析得出
    控制及状态寄存器		一共有32bit
        第0位		开启定时器的
        第1位		是否触发外部请求
        第2位		时钟源的选择
        第3-15位		保留
        第16位		判断计数是否计到0
        第17-31位		保留
    重装载值寄存器		一共有32bit
        第0-23位		存储重装载值[0 - 16M-1]
        第24-31位		保留
    当前值寄存器
        第0-23位		当前计数值[0 - 16M-1]
        第24-31位		保留
</code></pre>
<h1 id="二-中断"><a href="#二-中断" class="headerlink" title="二.中断"></a>二.中断</h1><pre><code>    之前写了LED灯的流水灯程序-&gt;延时使用的是粗略延时(空循环)
        使用精确的延时-&gt;使用了系统定时器
    之前写了功能按键的程序-&gt;轮询的方法检测按键是否被按下
        while(1)
        &#123;
            button_status(0);
        &#125;
        由于轮询的方法浪费资源,可以替换成中断的方法
    目的 : 把轮询检测按键的程序,修改成中断的方式处理功能按键
    1.了解轮询和中断的关系
        轮询 : CPU被绑定到检测的函数上,一直不断的调用
        是非常消耗CPU资源
        中断 : 在中断到来之前CPU可以处理任何事情,当中断到来之后
        会打断CPU,CPU调用中断处理函数
    2.介绍中断控制器
        VIC : 向量中断控制器
        NVIC : 可嵌套的向量中断控制器
        GIC : 通用的中断控制器
        一般来说VIC和NVIC是在单片机中使用的中断控制器
        一般来说GIC是在高端芯片中使用的中断控制器
        VIC和NVIC 相对于 GIC来说,在硬件上支持中断向量
        NVIC 相对于 VIC来说,在硬件上支持中断嵌套
    3.我们芯片上的中断控制器
        在STM32F103RBT6芯片中使用的是NVIC
        前提 : 
        有些手册会把NVIC画到ARM核心的内部
        有些手册会把NVIC画到ARM核心的外部
        有些手册会把NVIC画到紧贴着ARM核心
        想要表达的含义就是NVIC和ARM核心是紧密相联的关系
    NVIC和ARM-CORTEX-M3之间是紧密相联的关系
    NVIC中断控制器会做两个操作
        1)会为每一个连接到NVIC上的中断源分配一个中断号
        2)处理优先级的问题
            组优先级(抢占优先级)
            子优先级(占先式优先级)
</code></pre>
<p>nvic<br><img src="/images/2022-8-15_STM32/2022-8-15_STM32/note/06day/nvic.png"></p>
<pre><code>    4.GPIO触发中断的方法
        GPIO想要触发中断需要借助EXTI外设
        EXTI叫做外部中断
        EXTI仅仅是NVIC上的一个中断源而已
打开&lt;STM32RBT6\DataSheet\STM32&gt;目录下&lt;STM32F10x中文参考手册.pdf&gt;
    P89	NVIC以及异常向量表
    P91	EXTI的描述
        每组GPIO的0号管脚可以触发EXTI0
        每组GPIO的1号管脚可以触发EXTI1
        ...
        每组GPIO的15号管脚可以触发EXTI15
    ----------------------------------------------------
    已知KEY0按键使用的是PC9管脚,
    将来GPIOC9管脚想要触发中断需要使用EXTI9
    ----------------------------------------------------
    EXTI9只能由PC9触发吗?
    也可以是PA9 PB9 PC9触发,需要通过 AFIO外设 进行选择
    ----------------------------------------------------
    NVIC : 可嵌套的向量中断控制器
    EXTI : 外部中断
    EXTI仅仅是NVIC上的一个中断源而已
    ----------------------------------------------------
    中断号是中断号,外部中断号是外部中断号,是不一样的
    中断号 : 和异常向量表中异常处理函数的顺序有关
    外部中断号 : 和GPIO的管脚编号有关
    ----------------------------------------------------
    有些外部中断会自己享用一个中断号,有些外部中断会共用一个中断号
    
</code></pre>
<h1 id="三-驱动外部中断"><a href="#三-驱动外部中断" class="headerlink" title="三.驱动外部中断"></a>三.驱动外部中断</h1><pre><code>    把轮询检测按键的程序修改成中断的方式
    KEY0	PC9	EXTI9	上拉输入	下降沿触发
    KEY1	PC8	EXTI8	上拉输入	下降沿触发
    KEY2	PA0	EXTI0	下拉输入	上升沿触发
    需要通过AFIO外设为外部中断选择触发的管脚
    1.初始化eint
        1)通过APB2总线使能GPIOC组和GPIOA组以及AFIO的时钟
        (因为需要通过AFIO为外部中断选择触发的管脚)
        2)初始化功能按键使用的GPIO管脚
            1&gt;把PC9 PC8管脚配置为上拉输入模式
            2&gt;把PA0管脚配置为下拉输入模式
        3)为外部中断选择触发的管脚
            1&gt;为EXTI9选择由PC9触发
            2&gt;为EXTI8选择由PC8触发
            3&gt;为EXTI0选择由PA0触发
        4)初始化NVIC
            1&gt;配置组优先级和子优先级的所占比例
            2&gt;选择中断号
            3&gt;使能该中断
            4&gt;配置组优先级的级别
            5&gt;配置子优先级的级别
</code></pre>
<p>优先级所占比例<br><img src="/images/2022-8-15_STM32/2022-8-15_STM32/note/06day/%E4%BC%98%E5%85%88%E7%BA%A7%E6%89%80%E5%8D%A0%E6%AF%94%E4%BE%8B.png"></p>
<pre><code>        5)初始化EXTI
            1&gt;选择外部中断号
            2&gt;使能该外部中断
            3&gt;选择中断的模式
            4&gt;选择触发的方式

============================
作业
1.把今天讲过的内容完完整整的复习一遍
2.把外部中断的项目工程重新搭建一遍
3.使用中断 + 消抖的方法实现按键开关的项目工程
============================
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://naoemb.cf/2023/02/16/embsky/STM32/stm32_07day/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%BE%AE%E4%BF%A1%E5%A4%B4%E5%83%8F.jpg">
      <meta itemprop="name" content="naoemb">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="naoemb">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/16/embsky/STM32/stm32_07day/" class="post-title-link" itemprop="url">stm32_note_07day</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-16 08:03:05" itemprop="dateCreated datePublished" datetime="2023-02-16T08:03:05+08:00">2023-02-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-02 01:55:14" itemprop="dateModified" datetime="2022-09-02T01:55:14+08:00">2022-09-02</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>2022-8-23<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<h1 id="一-温故知新"><a href="#一-温故知新" class="headerlink" title="一.温故知新"></a>一.温故知新</h1><pre><code>    1.目的
    之前写过检测按键是否被按下的程序-&gt;使用的是轮询的方式检测-&gt;CPU很忙
    是把轮询检测的程序修改成了中断的方式-&gt;需要使用中断控制器
    2.介绍芯片中常见的中断控制器
    VIC	向量中断控制器		单片机芯片中常用
    NVIC	可嵌套的向量中断控制器	单片机芯片中常用
    GIC	通用的中断控制器		高端芯片中常用
    3.在STM32F103RBT6芯片中使用的是NVIC中断控制器
    NVIC中断控制器会处理两个事情
        1)为每一个连接到NVIC上的中断源分配一个中断号
        2)处理优先级(组优先级 和 子优先级)
    异常向量表中存储的是异常处理函数的函数名(异常处理函数的入口地址)
    异常向量表中异常处理函数的顺序和中断号是一一对应
    4.GPIO需要借助EXTI来触发中断
    EXTI叫做外部中断
    每一组GPIO的0号管脚都可以触发EXTI0
    每一组GPIO的1号管脚都可以触发EXTI1
    ...
    每一组GPIO的15号管脚都可以触发EXTI15
    需要通过AFIO外设为外部中断选择触发的GPIO管脚
    
</code></pre>
<h1 id="二-看门狗"><a href="#二-看门狗" class="headerlink" title="二.看门狗"></a>二.看门狗</h1><pre><code>    STM32F103RBT6芯片使用的核心是ARM-CORTEX-M3的核心
    在工控领域中经常会使用到看门狗外设,所以今天主要讲看门狗外设
    1.从最新选型手册中了解看门狗信息
打开&lt;STM32RBT6\DataSheet\STM32&gt;目录下&lt;ST_MCU最新选型手册.pdf&gt;
    P21
    看门狗属于定时器的资源,在STM32芯片中属于其他定时器资源
    在STM32芯片中有两个看门狗,分别是独立看门狗 和 窗口看门狗

    2.产生的问题
    1)查找看门狗的时钟频率?		40KHz
    2)查找看门狗的计数值范围?		[0 - 4095]
    3)看门狗提供的其他功能是什么?		重启系统

    3.看门狗的使用环境
    在工业的工作环境中,嵌入式设备经常会面临一些恶劣的工作环境:超高温、
    超低温、非常湿润、非常干燥、强烈的电磁干扰,这些环境都会影响嵌入式设备
    的正常工作,有可能会造成设备死机 或者 设备中运行的程序直接跑飞
    所以可以使用看门狗帮助程序员监测嵌入式设备是否死机或者程序跑飞
    一旦设备死机了或者程序跑飞了,看门狗可以帮助程序员重启系统

    4.看门狗的简介
    既然看门狗属于定时器的资源,那么决定定时长短是由时钟频率和计数值范围
    来决定的,
    和普通定时器不同,普通定时器定时到了之后,去处理程序员指定要做的事情
    看门狗定时到了之后,直接重启系统(效果和按下reset按键一样)
    如果设备死机了,看门狗可以帮助程序员重启系统
    如果设备没有死机,看门狗不需要重启系统
    (只要让看门狗的计数器永远计不到0,看门狗就不会重启系统了)

    5.喂狗(feed dog)
    需要每隔一段时间,往看门狗的计数器中重新写入计数值,让看门狗永远计不到0

    6.介绍STM32芯片内部的看门狗
    在STM32芯片中有两种看门狗
    独立看门狗 : (IWDG)
    窗口看门狗 : (WWDG)
    注意 : 一般来说高端的芯片中只有一个看门狗,更像是独立看门狗

    7.独立看门狗和窗口看门狗的区别
    相同点
        1)IWDG和WWDG都是由STM32芯片提供的外设资源
        2)IWDG和WWDG功能一样,都会因为设备死机或者程序跑飞,
            重启系统
        3)IWDG和WWDG都可以自行调节喂狗时间
    不同点
        1)时钟源不同
            IWDG使用的是独立RC(LSI&lt;40KHz&gt;)提供的时钟
            不需要使用总线使能时钟
            WWDG使用是APB1总线提供的时钟
            需要通过APB1总线使能WWDG的时钟
        2)产生中断不同
            IWDG是没有中断的,只要IWDG计到0,直接重启系统
            WWDG是有中断,只要计数器超时,可以触发中断
        3)计数的方式不同
            IWDG使用的是12bit的计数器
            WWDG使用的是7bit的计数器
        4)喂狗的时间范围不同
            IWDG只要计数器计到0之前,任意时间喂狗都可以
            WWDG会有一个上阙值和下阙值
</code></pre>
<h1 id="三-独立看门狗"><a href="#三-独立看门狗" class="headerlink" title="三.独立看门狗"></a>三.独立看门狗</h1><pre><code>    打开&lt;STM32RBT6\DataSheet\STM32&gt;目录下
    &lt;STM32F10x中文参考手册.pdf&gt;
    P276
    IWDG使用的是LSI(40KHz)的时钟源
    IWDG是一个递减的计数器(向下计数)
    IWDG的计数器计数到0时会产生系统复位
    
    IWDG_KR(键寄存器)&lt;写入特定的值会有特定的操作&gt;
    0xAAAA		喂狗的操作
    0x5555		开启IWDG_PR和OWDG_RLR寄存器的写访问
    0xCCCC		开启看门狗
    
    IWDG_PR(预分频寄存器)&lt;给IWDG的时钟频率进行分频的&gt;
    注意 : 在操作IWDG_PR寄存器之前需要先给IWDG_KR寄存器写入0x5555
    开启IWDG_PR寄存器的写访问(关闭写保护)
    000 4分频		100 64分频
    001 8分频		101 128分频
    010 16分频	110 256分频
    011 32分频	111 256分频

    IWDG_RLR(重装载值寄存器)&lt;是用来存储计数值的&gt;
    注意 : 在操作IWDG_RLR寄存器之前需要先给IWDG_KR寄存器写入0x5555
    开启IWDG_RLR寄存器的写访问(关闭写保护)
    该寄存器只有低12bit有效
    可以存储的计数值是[12个0 - 12个1]&lt;0 - 4095&gt;
</code></pre>
<h1 id="四-传感器"><a href="#四-传感器" class="headerlink" title="四.传感器"></a>四.传感器</h1><pre><code>    1.传感器的简介
    在物联网嵌入式的项目框架中,需要使用嵌入式设备采集感知周围的数据
    那么需要使用传感器进行采集和感知,在市面上的传感器的种类有很多
    检测气体 : 温度、湿度、空气中的微颗粒物(PM2.5、PM1.0)
        稀有气体的含量(一氧化碳、二氧化碳、氧气、甲烷、乙醇、甲醛)
    检测液体 : 温度、浑浊度、PH值、液位
    检测固体 : 土壤湿度、微量元素的含量
    检测人体 : 体温、血压、血糖、心率
    ...
    本身市面上的传感器的种类有很多很多种
    2.传感器接口的简介
    GPIO接口、串口接口(USART/UART、IIC、SPI...)、并口接口
    数字型的传感器 : 可以直接采集到数字量,可以直接交给CPU去处理
    模拟型的传感器 : 采集到的是模拟量,需要经过AD转换,
        转换成了数字量再交给CPU去处理
</code></pre>
<h1 id="五-DHT11传感器"><a href="#五-DHT11传感器" class="headerlink" title="五.DHT11传感器"></a>五.DHT11传感器</h1><pre><code>    DHT11传感器是一个温湿度的传感器(是专门用来检测温度和湿度的)
    外观上来看是4引脚的封装形式
    打开&lt;STM32RBT6\DataSheet\传感器&gt;目录下
    &lt;DHT11说明书.pdf&gt;和&lt;DHT22.pdf&gt;
    1.DHT11是一个数字型的传感器
    2.DHT11是用来采集温湿度的数据
    3.DHT11是4引脚的封装形式
    4.测量范围		湿度:20%-90%	温度:0℃-50℃
    5.误差范围		湿度:±5%		温度:±2℃
    6.分辨力为1	DHT11只能检测到整数数据
    7.1pin连接电源 2pin连接MCU 3pinNC(悬空&lt;没有连接&gt;) 4pin连接地
</code></pre>
<p>上拉电阻<br><img src="/images/2022-8-15_STM32/2022-8-15_STM32/note/07day/%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB.png"><br>下拉电阻<br><img src="/images/2022-8-15_STM32/2022-8-15_STM32/note/07day/%E4%B8%8B%E6%8B%89%E7%94%B5%E9%98%BB.png"></p>
<pre><code>    8.DHT11是串行接口 : 指的是数据以串行的方式进行传输
         串行的方式 : 指的是按顺序一位一位的传输数据
    9.单线双向指的是半双工工作模式(发送的同时不能接收,接收的同时不能发送)
</code></pre>
<p>串行传输<br><img src="/images/2022-8-15_STM32/2022-8-15_STM32/note/07day/%E4%B8%B2%E8%A1%8C%E4%BC%A0%E8%BE%93.png"></p>
<pre><code>    A.一次完整的数据传输为40bit,高位先出.
    
    例子 : DHT11的数据管脚连接到了STM32的PC10管脚
    需要通过PC10管脚发送数据或者接收数据
    1)通过PC10管脚发送数据(高位先出)
    data = 10110100;
    data		&amp;		PCOut(10)
第1次循环	10110100	10000000	1
第2次循环	01101000	10000000	0
第3次循环	11010000	10000000	1
第4次循环	10100000	10000000	1
第5次循环	01000000	10000000	0
第6次循环	10000000	10000000	1
第7次循环	00000000	10000000	0
第8次循环	00000000	10000000	0
        void func(u8 data)//通过PC10管脚把形参data存储的数据发送
        &#123;
            u8 i = 0;//循环变量
            for(i =0 ; i &lt; 8; i++)
            &#123;
                if(data &amp; 0x80)
                    PCOut(10) = 1;
                else
                    PCOut(10) = 0;
                data &lt;&lt;= 1;
            &#125;	
        &#125;

    2)通过PC10管脚发送数据(低位先出)
    data		&amp;		PCOut(10)
第1次循环	10110100	00000001	0
第2次循环	01011010	00000001	0
第3次循环	00101101	00000001	1
第4次循环	00010110	00000001	0
第5次循环	00001011	00000001	1
第6次循环	00000101	00000001	1
第7次循环	00000010	00000001	0
第8次循环	00000001	00000001	1
        void func(u8 data)
        &#123;
            u8 i = 0;//循环变量
            for(i = 0; i &lt; 8; i++)
            &#123;
                if(data &amp; 0x01)
                    PCOut(10) = 1;
                else
                    PCOut(10) = 0;
                data &gt;&gt;= 1;
            &#125;
        &#125;
    3)通过PC10管脚读取数据(高位先出)
    DHT11要发送10110100
    PCIn(10)	data &lt;&lt;=1	data
第1次循环	1	00000000	00000001
第2次循环	0	00000010	00000010
第3次循环	1	00000100	00000101
第4次循环	1	00001010	00001011
第5次循环	0	00010110	00010110
第6次循环	1	00101100	00101101
第7次循环	0	01011010	01011010
第8次循环	0	10110100	10110100
        u8 func(void)
        &#123;
            u8 data = 0;//保存读取到的数据
            u8 i = 0;//循环变量
            
            for(i = 0; i &lt; 8; i++)
            &#123;
                data &lt;&lt;= 1;
                if(PCIn(10) == 1)
                    data |= 1;
            &#125;
            
            return data;
        &#125;
    4))通过PC10管脚读取数据(低位先出)
    DHT11要发送10110100
    PCIn(10)	data &gt;&gt;=1	data
第1次循环	0	00000000	00000000
第2次循环	0	00000000	00000000
第3次循环	1	00000000	10000000
第4次循环	0	01000000	01000000
第5次循环	1	00100000	10100000
第6次循环	1	01010000	11010000
第7次循环	0	01101000	01101000
第8次循环	1	00110100	10110100
        u8 func(void)
        &#123;
            u8 data = 0;//保存读取到的数据
            u8 i = 0;//循环变量
            
            for(i = 0; i &lt; 8; i++)
            &#123;
                data &gt;&gt;= 1;
                if(PCIn(10) == 1)
                    data |= 0x80;
            &#125;
            
            return data;
        &#125;

===========================
作业
1.把今天讲过的内容完完整整的复习一遍
2.可以使用操作寄存器的方法驱动一下独立看门狗
3.根据手册操作一下窗口看门狗
4.在纸上写一遍串行接口发送数据和接收数据(高位先出和低位先出)
===========================
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://naoemb.cf/2023/02/16/embsky/STM32/stm32_01day/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%BE%AE%E4%BF%A1%E5%A4%B4%E5%83%8F.jpg">
      <meta itemprop="name" content="naoemb">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="naoemb">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/16/embsky/STM32/stm32_01day/" class="post-title-link" itemprop="url">stm32_note_01day</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-16 08:03:05" itemprop="dateCreated datePublished" datetime="2023-02-16T08:03:05+08:00">2023-02-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-02 01:54:37" itemprop="dateModified" datetime="2022-09-02T01:54:37+08:00">2022-09-02</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>2022-8-15<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<h1 id="一-进入新的阶段"><a href="#一-进入新的阶段" class="headerlink" title="一.进入新的阶段"></a>一.进入新的阶段</h1><pre><code>    STM32阶段(智能终端设备阶段)
    原由
    1.为了从应用层到底层内核驱动的过渡
    2.在高端的开发板上讲带操作系统的驱动,裸板驱动在STM32上讲
    3.国家大力的推广5G技术(海量物联)-&gt;所以需要讲智能终端设备
</code></pre>
<h1 id="二-阶段性项目"><a href="#二-阶段性项目" class="headerlink" title="二.阶段性项目"></a>二.阶段性项目</h1><pre><code>    物联网智能终端的产品
    基础的物联网项目架构
    分为4个层次
        感知层
        网络层
        平台层
        应用层
    新型的物联网项目框架会加入边缘计算设备
    物联网的两个分支
    智能终端设备 : 单片机的内容
    边缘计算设备 : 高端芯片的内容
    小爱同学
    天猫精灵
    小度小度
</code></pre>
<p>基础的物联网项目架构<br><img src="/images/2022-8-15_STM32/2022-8-15_STM32/note/01day/%E5%9F%BA%E7%A1%80%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84.png"></p>
<h1 id="三-安装开发环境"><a href="#三-安装开发环境" class="headerlink" title="三.安装开发环境"></a>三.安装开发环境</h1><pre><code>    同学们在飞秋上，下载压缩包&lt;STM32RBT6_SDK.zip&gt;
    同学们在电脑上安装一个好用的PDF阅读器
    1.把windows操作系统上的文件扩展名先显示出来
    2.把压缩包&lt;STM32RBT6_SDK.zip&gt;解压一下
    3.工具包文件的认知
        &lt;DataSheet&gt;	存放的都是数据手册
        &lt;ST官方固件&gt;	存放的都是ST公司的官方固件
        &lt;开发板原理图&gt;	存放的是开发板原理图
        &lt;开发工具&gt;	存放的是单片机开发会用到的工具
    4.安装集成的开发环境
    在&lt;STM32RBT6\开发工具\MDK520&gt;中&lt;MDK520.exe&gt;
    双击安装
        1)在安装Keil时安装路径！！！千万不要有中文！！！
        2)在安装Keil时有填写 姓 名 公司名称 邮箱 都写数字 1 即可
        3)在安装最后有可能会弹出小对话框问是否安装驱动,选择安装
        4)安装结束会弹出网页以及联网安装补丁,都选择关闭

    手动安装补丁
    在&lt;STM32RBT6\开发工具\MDK520&gt;中5个.pack结尾的文件
    安装从上往下的顺序,依次双击安装
    
    仿真器的驱动
    STLink仿真器的驱动
    在&lt;STM32RBT6\开发工具\STLink V2驱动\STLINK_V2_USBDriver&gt;中
    如果Windows系统是64bit的就安装&lt;dpinst_amd64.exe&gt;
    如果Windows系统是32bit的就安装&lt;dpinst_x86.exe&gt;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://naoemb.cf/2023/02/16/embsky/STM32/stm32_02day/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%BE%AE%E4%BF%A1%E5%A4%B4%E5%83%8F.jpg">
      <meta itemprop="name" content="naoemb">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="naoemb">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/16/embsky/STM32/stm32_02day/" class="post-title-link" itemprop="url">stm32_note_02day</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-16 08:03:05" itemprop="dateCreated datePublished" datetime="2023-02-16T08:03:05+08:00">2023-02-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-02 01:54:47" itemprop="dateModified" datetime="2022-09-02T01:54:47+08:00">2022-09-02</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>2022-8-16<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<h1 id="一-温故知新"><a href="#一-温故知新" class="headerlink" title="一.温故知新"></a>一.温故知新</h1><pre><code>    1.搭建了物联网项目框架
        感知层	智能终端设备的裸板驱动
            STM32F103RBT6
        网络层	WiFi模块
        平台层	华为	OceanConnect//太繁琐(安全性高)
            小米	小米IoT//企业用户
            阿里	AIoT//繁琐(安全性高)
            百度	天工//添加设备丰富
            移动	OneNet//简单
            联通	中国联通物联网//没用过
            东方瑞通	ESLink
        应用层	只要是提供了云平台都会提供应用层的APP
    2.在基础版本的物联网项目框架中引入边缘计算设备
    3.两个分支
        智能终端设备
        边缘计算设备
    4.安装开发环境

学习的时候注重的是过程
工作的时候注重的是结果
</code></pre>
<h1 id="二-从表象到里象的方式了解开发板"><a href="#二-从表象到里象的方式了解开发板" class="headerlink" title="二.从表象到里象的方式了解开发板"></a>二.从表象到里象的方式了解开发板</h1><pre><code>    1.从外观入手(查看配件有哪些以及芯片的型号)
    打开&lt;STM32RBT6\开发板原理图&gt;目录下&lt;stm32-mix.jpg&gt;
    2.了解芯片的结构
    通过画图了解
    无论是SOC(高端的芯片)还是MCU(单片机芯片)
    都是可以自己组成微型的计算机系统	
    STM32F103RBT6 = CPU + 内存 + 硬盘 + 外设
        CPU = ARM-CORTEX-M3(用来做大量计算,处理数据)
        内存 = 运行程序时会占用的空间
        硬盘 = 保存烧写的程序
        外设 = 操作芯片功能的接口
</code></pre>
<p>01MCU内部结构<br><img src="/images/2022-8-15_STM32/2022-8-15_STM32/note/02day/01MCU%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png"></p>
<pre><code>    S5P6818 = CPU + 内存 + 硬盘 + 外设
        CPU = ARM-CORTEX-A53(用来做大量计算,处理数据)
        内存 = 运行硬盘中固件会占用的空间
        硬盘 = 存储的是芯片厂商烧写好的固件(Read Only)
        外设 = 操作芯片功能的接口
    注意 : 高端芯片外部需要外接内存，外接硬盘
</code></pre>
<p>01SOC内部结构<br><img src="/images/2022-8-15_STM32/2022-8-15_STM32/note/02day/02SOC%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png"></p>
<h1 id="三-介绍ARM公司和ST公司"><a href="#三-介绍ARM公司和ST公司" class="headerlink" title="三.介绍ARM公司和ST公司"></a>三.介绍ARM公司和ST公司</h1><pre><code>    ARM公司是在英国剑桥成立，在2016年年底被日本软银收购
    嵌入式领域芯片架构
    曾经三足鼎立
        PPC	游戏机/掌机
        MIPS	路由器/交换机、网络探头
        ARM	手机
    现在
        MIPS	
        ARM	各种电子产品
    ST公司，意法半导体公司，在2020年国家统计数据，
    咱们国家使用ST公司的芯片NO.1
</code></pre>
<h1 id="四-开发方式"><a href="#四-开发方式" class="headerlink" title="四.开发方式"></a>四.开发方式</h1><pre><code>    1.传统开发方式
        使用C语言的位运算符操作芯片外设的寄存器
        &lt;&lt; &gt;&gt; &amp; | ~ ^
        对于驱动开发工程师来说容易出错
        需要驱动开发工程师写驱动 + 业务逻辑
    2.流行开发方式
        使用ST公司的官方固件(LIB库)
        涉及到函数调用即可
        需要驱动开发工程师写驱动 + 业务逻辑
    3.未来开发方式
        使用STM32CUBEMX开发工具 + 官方固件(HAL库)
        涉及到函数调用即可
        需要驱动开发工程师写业务逻辑
</code></pre>
<h1 id="五-搭建模板项目工程"><a href="#五-搭建模板项目工程" class="headerlink" title="五.搭建模板项目工程"></a>五.搭建模板项目工程</h1><pre><code>    1.模板项目工程只有在刚开始会教大家搭建，后面的项目工程直接拷贝使用
    2.搭建模板项目工程的流程必须要会
    3.搭建模板项目工程的方法并不唯一

前提准备 : 把Windows系统下,文件的扩展名显示出来
    1.创建目录结构
    在&lt;桌面&gt;上新建文件夹,重命名为&lt;stm32f103&gt;
    在&lt;桌面\stm32f103&gt;目录中新建文件夹,重命名为&lt;01test&gt;
    在&lt;桌面\stm32f103\01test&gt;目录中新建文件夹
        cmsis	存放有关arm-cortex-m系列的文件
        fwlib	存放的是ST公司的官方固件
        mylib	存放的是程序员自己写的固件
        project	存放的是项目工程文件
        user	存放的是主文件
&lt;STM32RBT6\ST官方固件\STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\CoreSupport&gt;目录下的所有文件
拷贝到
&lt;桌面\stm32f103\01test\cmsis&gt;

&lt;STM32RBT6\ST官方固件\STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm&gt;
目录下的&lt;startup_stm32f10x_md.s&gt;
拷贝到
&lt;桌面\stm32f103\01test\cmsis&gt;

&lt;STM32RBT6\ST官方固件\STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\STM32F10x_StdPeriph_Driver&gt;目录下的&lt;inc&gt;和&lt;src&gt;
拷贝到
&lt;桌面\stm32f103\01test\fwlib&gt;

&lt;STM32RBT6\ST官方固件\STM32F10x_StdPeriph_Lib_V3.5.0\Project\STM32F10x_StdPeriph_Template&gt;目录下的
&lt;main.c&gt; &lt;stm32f10x_conf.h&gt; &lt;stm32f10x_it.c&gt;
&lt;stm32f10x_it.h&gt; &lt;system_stm32f10x.c&gt;
&lt;system_stm32f10x.h&gt;
拷贝到
&lt;桌面\stm32f103\01test\user&gt;	

    2.通过Keil搭建项目工程
    Define
    STM32F10X_MD,USE_STDPERIPH_DRIVER
        1&gt;在桌面上运行KEIL软件
        2&gt;如果默认打开的keil界面显示的是上一次的项目工程可以在keil的菜单栏&lt;Project&gt;中选择Close Project
        3&gt;在keil的菜单栏&lt;Project&gt;中选择New μVision Project
        4&gt;弹出了Create New Project对话框,选择新的项目工程创建的位置(选择之前项目工程创建的位置)
        5&gt;弹出了Select Device For Target对话框，可以在Search这一栏录入要操作的芯片型号&lt;STM32F103RB&gt;
        6&gt;点击左下角显示的找到的芯片型号，右边Description显示了芯片信息之后，点击OK
        7&gt;会弹出Manager Run-Time Environment的对话框，直接关闭
        8&gt;把keil默认的项目工程的层次结构调整成和windows下自己搭建的层次结构一致
        9&gt;点击第三行菜单栏中的Manager Project Items
        A&gt;在Project Targets这一栏中，把Target 1 修改成 Target //注意:双击蓝色的这一条可以编辑
        B&gt;在Groups这一栏中，把Source Group1去掉，添加上cmsis fwlib mylib user 4个组
        C&gt;首先在Groups这一栏中，选择cmsis这个组，然后在对话框右下角点击Add Files
        D&gt;弹出对话框&lt;Add Files To Group &#39;cmsis&#39;&gt;，默认的查找范围是project，找到自己创建的cmsis目录
        //注意:在这一步添加文件，只需要添加.c .s文件即可，不需要添加.h文件
        E&gt;在cmsis目录中选择core_cm3.c文件和startup_stm32f10x_md.s添加到cmsis组中即可
        F&gt;选择fwlib的组继续添加文件，找到stm32f10x_rcc.c文件，添加到fwlib组中
        G&gt;选择user的组继续添加文件，找到main.c stm32f10x_it.c system_stm32f10x.c，添加到user组中
        H&gt;在Manager Project Items的对话框中点击OK
        I&gt;在keil界面的左边的Project栏中，找到main.c文件，双击打开
        J&gt;在main.c文件中全选文件内容，全部删掉，加入自己写得main函数//注意:在文件最后一定要多加几个空行
        K&gt;在keil的第三行菜单栏中选择 Options for Target &#39;Target&#39;这一项
        L&gt;在对话框中选择C/C++这一项，在Define：这一栏中填入 STM32F10X_MD,USE_STDPERIPH_DRIVER
        M&gt;在C/C++这一项中，找到Include Paths，在这一项中添加头文件的路径
        N&gt;在Include Paths这一行最后有一个三个点的按钮，点击，弹出Folder Setup对话框
        O&gt;在Folder Setup对话框中选择4个路径即可 cmsis fwlib\inc mylib user
        P&gt;添加完之后，点击OK，跳出对话框
        Q&gt;开始编译项目工程，点击keil的第三行菜单栏的Rebuild的按钮
        R&gt;在keil中设置仿真器，(1.安装仿真器的驱动 2.把开发板连接到电脑上 3.开发板上电)
        S&gt;在keil的第三行菜单栏中选择 Options for Target &#39;Target&#39;这一项
        T&gt;在Options for Target &#39;Target&#39;对话框的菜单栏中选择Debug，在Debug菜单中的右测下拉菜单中选择ST-Link Debugger
        U&gt;选择ST-Link Debugger之后选择之后的Settings按钮，弹出Cortex-M  Target  Driver Setup对话框
        V&gt;如果在SWDIO中确定有一串十六进制的数字，那么keil识别了开发板的仿真器
        W&gt;在Cortex-M  Target  Driver Setup对话框中选择，Flash Download菜单，在Download Function中选择上Reset and Run
        X&gt;在对话框中选择OK，退出对话框
        Y&gt;在KEIL的第三行菜单栏中选择 Download 按钮，下载程序(确保程序编译没有错误没有警告)	

=================================
1.重新搭建项目工程
=================================
</code></pre>
<h1 id="六-通过数据手册了解芯片内部的结构"><a href="#六-通过数据手册了解芯片内部的结构" class="headerlink" title="六.通过数据手册了解芯片内部的结构"></a>六.通过数据手册了解芯片内部的结构</h1><pre><code>    1.通过数据手册了解芯片内部外设的数量
打开&lt;STM32RBT6\DataSheet\STM32&gt;目录下&lt;ST_MCU最新选型手册.pdf&gt;
    硬盘		128Kb
    内存		20Kb
    封装形式		64管脚的封装形式
    定时器		4个16bit的定时器(普通定时器) + 其他定时器
            2个看门狗、实时时钟、24bit向下计数定时器
    ADC(模/数转换器)	16×12bit
    GPIO		51个
    串口		2个SPI、2个I²C、3个USART/UART、
            1个USB、1个CAN
    电压范围		2.0V - 3.6V
    &lt;最新选型手册&gt;在公司中是在项目立项的时候会使用(技术总监、组长)
    1.你选择的芯片的外设资源可以满足你的所有需求
    2.在满足第一点的条件下，其他外设资源越少越好
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://naoemb.cf/2023/02/16/embsky/C%E5%BC%80%E5%8F%91%E7%AC%94%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%BE%AE%E4%BF%A1%E5%A4%B4%E5%83%8F.jpg">
      <meta itemprop="name" content="naoemb">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="naoemb">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/16/embsky/C%E5%BC%80%E5%8F%91%E7%AC%94%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">C开发笔试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-16 08:03:05" itemprop="dateCreated datePublished" datetime="2023-02-16T08:03:05+08:00">2023-02-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-25 01:16:39" itemprop="dateModified" datetime="2022-10-25T01:16:39+08:00">2022-10-25</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1NeJomt4s6WGplWDW4pCFAQ?pwd=9527">C开发笔试题.zip 提取码：9527</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://naoemb.cf/2023/02/16/embsky/C%E8%AF%AD%E8%A8%80%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%BE%AE%E4%BF%A1%E5%A4%B4%E5%83%8F.jpg">
      <meta itemprop="name" content="naoemb">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="naoemb">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/16/embsky/C%E8%AF%AD%E8%A8%80%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">C语言执行流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-16 08:03:05" itemprop="dateCreated datePublished" datetime="2023-02-16T08:03:05+08:00">2023-02-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-30 20:21:50" itemprop="dateModified" datetime="2022-08-30T20:21:50+08:00">2022-08-30</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/C%E8%AF%AD%E8%A8%80%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="C语言执行流程"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://naoemb.cf/2023/02/16/embsky/04ds/%E9%93%BE%E8%A1%A8%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%BE%AE%E4%BF%A1%E5%A4%B4%E5%83%8F.jpg">
      <meta itemprop="name" content="naoemb">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="naoemb">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/16/embsky/04ds/%E9%93%BE%E8%A1%A8%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">04ds_链表面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-16 08:03:05" itemprop="dateCreated datePublished" datetime="2023-02-16T08:03:05+08:00">2023-02-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-02 01:53:46" itemprop="dateModified" datetime="2022-09-02T01:53:46+08:00">2022-09-02</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code># 移出链表元素
给你一个无头单向不循环链表的首结点l和一个整数 val ，请你删除链表中所有等于 val 的节点，并返回新的首结点 。
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct llist_node</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct llist_node *next;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> llist_node* <span class="title function_">removeElements</span><span class="params">(<span class="keyword">struct</span> llist_node* l, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>* <span class="title">cur</span> =</span> l;<span class="comment">//指向要删除的结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>* <span class="title">back</span> =</span> <span class="literal">NULL</span>;<span class="comment">//指向要删除的结点的前一个位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)<span class="comment">//判断是否遍历完所有结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;val == val)<span class="comment">//判断当前指向的结点是否是要删除的结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(back == <span class="literal">NULL</span>)<span class="comment">//判断删除的是否是链表的首结点</span></span><br><span class="line">            &#123;</span><br><span class="line">	l = cur-&gt;next;<span class="comment">//让l指针指向下一个结点</span></span><br><span class="line">                <span class="built_in">free</span>(cur);<span class="comment">//释放首结点</span></span><br><span class="line">                cur = l;<span class="comment">//让cur指针指向新的首结点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//如果删除的不是首结点就按照普通的删除方法进行</span></span><br><span class="line">            &#123;</span><br><span class="line">                back-&gt;next = cur-&gt;next;</span><br><span class="line">                <span class="built_in">free</span>(cur);</span><br><span class="line">                cur = back-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//如果不是要删除的结点，找下一个结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            back = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;<span class="comment">//返回指向首结点的指针l</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

# 反转链表
给你一个无头单向不循环链表的首结点l ，请你反转链表，并返回反转后的链表首结点
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct llist_node</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct llist_node *next;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> llist_node* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> llist_node* l)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span> *<span class="title">cur</span> =</span> l;<span class="comment">//cur指针指向当前操作的结点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;<span class="comment">//p指针指向原链表中cur的下一个位置</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span> *<span class="title">next</span> =</span> <span class="literal">NULL</span>;<span class="comment">//next指针指向反转链表后cur的下一个位置</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(cur != <span class="literal">NULL</span>)<span class="comment">//判断是否遍历完整个链表</span></span><br><span class="line">	&#123;</span><br><span class="line">		p = cur-&gt;next;<span class="comment">//p指针指向原链表中cur的下一个位置</span></span><br><span class="line">		cur-&gt;next = next;<span class="comment">//让cur指针指向的结点的next指向前一个位置</span></span><br><span class="line">		next = cur;<span class="comment">//移动next</span></span><br><span class="line">		cur = p;<span class="comment">//移动cur</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

# 链表的中间结点
给定一个头结点为handler的单向不循环链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct llist_node</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct llist_node *next;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//快慢指针</span></span><br><span class="line"><span class="comment">//慢指针一次走一步，慢指针一次走两步</span></span><br><span class="line"><span class="keyword">struct</span> llist_node* <span class="title function_">middleNode</span><span class="params">(<span class="keyword">struct</span> llist_node* handler)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span> *<span class="title">s</span> =</span> handler;<span class="comment">//慢指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span> *<span class="title">f</span> =</span> handler;<span class="comment">//快指针</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(f != <span class="literal">NULL</span> &amp;&amp; f-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		s = s-&gt;next;</span><br><span class="line">		f = f-&gt;next-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

# 链表中倒数第k个结点
给定一个头结点为handler的单向不循环链表，输出该链表中倒数第k个结点。
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct llist_node</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct llist_node *next;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//先让一个指针走k个结点，再让另外一个指针跟着走</span></span><br><span class="line"><span class="keyword">struct</span> llist_node* <span class="title function_">FindKthToTail</span><span class="params">(<span class="keyword">struct</span> llist_node* handler, <span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span> *<span class="title">s</span> =</span> handler;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span> *<span class="title">f</span> =</span> handler;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(k--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(f == <span class="literal">NULL</span>)<span class="comment">//判断k值是否大于链表节点数</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		f = f-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(f != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		s = s-&gt;next;</span><br><span class="line">		f = f-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

# 合并两个有序链表
将两个升序的无头单向不循环链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct llist_node</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct llist_node *next;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> llist_node* <span class="title function_">mergeTwoLists</span><span class="params">(<span class="keyword">struct</span> llist_node* l1, <span class="keyword">struct</span> llist_node* l2)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span> *<span class="title">l</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span> *<span class="title">cur</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(l1 == <span class="literal">NULL</span>)<span class="comment">//判断l1链表是否不存在</span></span><br><span class="line">		<span class="keyword">return</span> l2;</span><br><span class="line">	<span class="keyword">if</span>(l2 == <span class="literal">NULL</span>)<span class="comment">//判断l2链表是否不存在</span></span><br><span class="line">		<span class="keyword">return</span> l1;</span><br><span class="line">	<span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">	&#123;</span><br><span class="line">		l = cur = l1;</span><br><span class="line">		l1 = l1-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		l = cur = l2;</span><br><span class="line">		l2 = l2-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">		&#123;</span><br><span class="line">			cur-&gt;next = l1;</span><br><span class="line">			l1 = l1-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cur-&gt;next = l2;</span><br><span class="line">			l2 = l2-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		cur = cur-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(l1 == <span class="literal">NULL</span>)</span><br><span class="line">		cur-&gt;next = l2;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cur-&gt;next = l1;</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

# 链表分割
现有一无头单向不循环链表的首结点指针l，给一定值x，编写一段代码将所有小于x的结点排在其余结点之前，且不能改变原来的数据顺序，返回重新排列后的链表的头指针。
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct llist_node</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct llist_node *next;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> llist_node* <span class="title function_">partition</span><span class="params">(<span class="keyword">struct</span> llist_node* l, <span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span> *<span class="title">cur</span> =</span> l;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span> *<span class="title">minhead</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span> *<span class="title">maxhead</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span> *<span class="title">mincur</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span> *<span class="title">maxcur</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	minhead = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> llist_node));</span><br><span class="line">	maxhead = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> llist_node));</span><br><span class="line">	minhead-&gt;next = maxhead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	mincur = minhead;</span><br><span class="line">	maxcur = maxhead;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(cur != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(cur-&gt;val &lt; x)</span><br><span class="line">		&#123;</span><br><span class="line">			mincur-&gt;next  = cur;</span><br><span class="line">			mincur = mincur-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			maxcur-&gt;next = cur;</span><br><span class="line">			maxcur = maxcur-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		cur = cur-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	mincur-&gt;next = maxhead-&gt;next;</span><br><span class="line">	maxcur-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	l = minhead-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(minhead);</span><br><span class="line">	<span class="built_in">free</span>(maxhead);</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

# 链表的回文结构
`现有一无头单向不循环链表的首结点指针l，请返回一个bool值，代表其是否为回文结构。`

# 环形链表
`给你一个单向链表的头结点 head ，判断链表中是否有环。`

# 单向不循环链表的排序
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct llist_node</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct llist_node *next;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> llist_node *<span class="title function_">pop_sort</span><span class="params">(<span class="keyword">struct</span> llist_node *l)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> llist_node *p, *q, *tail;</span><br><span class="line">    tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>((l-&gt;next-&gt;next) != tail)</span><br><span class="line">    &#123;</span><br><span class="line">        p = l;</span><br><span class="line">        q = l-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(q-&gt;next != tail)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((q-&gt;val) &gt; (q-&gt;next-&gt;val))</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next = q-&gt;next;</span><br><span class="line">                q-&gt;next = q-&gt;next-&gt;next;</span><br><span class="line">                p-&gt;next-&gt;next = q;</span><br><span class="line">                q = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://naoemb.cf/2023/02/16/embsky/04ds/04ds_08day/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%BE%AE%E4%BF%A1%E5%A4%B4%E5%83%8F.jpg">
      <meta itemprop="name" content="naoemb">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="naoemb">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/16/embsky/04ds/04ds_08day/" class="post-title-link" itemprop="url">04ds_08day</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-16 08:03:05" itemprop="dateCreated datePublished" datetime="2023-02-16T08:03:05+08:00">2023-02-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-02 01:53:37" itemprop="dateModified" datetime="2022-09-02T01:53:37+08:00">2022-09-02</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>2022-8-10<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<h1 id="note"><a href="#note" class="headerlink" title="note"></a>note</h1><pre><code>一.温故知新
    栈式的存储结构
        先进后出
    队列式的存储结构
        先进先出
    无论是顺序表还是链表都可以实现
    栈式
    struct node
    &#123;
        int stack[6];
        int ind;
    &#125;;
    队列
    struct node
    &#123;
        int queue[6];
        int front;
        int rear;
    &#125;;

    静态库和动态库
早测 
1.链表中倒数第k个结点
给定一个头结点为handler的单向不循环链表
输出该链表中倒数第k个结点
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> llist_node *<span class="title function_">func</span><span class="params">(<span class="keyword">struct</span> llist_node *l, <span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span> *<span class="title">s</span> =</span> l;<span class="comment">//慢指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span> *<span class="title">f</span> =</span> l;<span class="comment">//快指针</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(k--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(f == <span class="literal">NULL</span>)<span class="comment">//判断链表是否提前结束</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		f = f-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(f != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		s = s-&gt;next;</span><br><span class="line">		f = f-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

2.合并两个有序链表
将两个升序的无头单向不循环链表合并为一个新的升序链表并返回
新链表是通过拼接给定的两个链表的所有节点组成的
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> llist_node *<span class="title function_">func</span><span class="params">(<span class="keyword">struct</span> llist_node *l1, <span class="keyword">struct</span> llist_node *l2)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span> *<span class="title">l</span> =</span> <span class="literal">NULL</span>;<span class="comment">//指向合并之后的链表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span> *<span class="title">cur</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(l1 == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> l2;</span><br><span class="line">	<span class="keyword">if</span>(l2 == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> l1;</span><br><span class="line">	<span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">	&#123;</span><br><span class="line">		l = cur = l1;</span><br><span class="line">		l1 = l1-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		l = cur = l2;</span><br><span class="line">		l2 = l2-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">		&#123;</span><br><span class="line">			cur-&gt;next = l1;</span><br><span class="line">			l1 = l1-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cur-&gt;next = l2;</span><br><span class="line">			l2 = l2-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		cur = cur-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(l1 != <span class="literal">NULL</span>)</span><br><span class="line">		cur-&gt;next = l1;</span><br><span class="line">	<span class="keyword">if</span>(l2 != <span class="literal">NULL</span>)</span><br><span class="line">		cur-&gt;next = l2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


3.简答题
给定一个有头单向不循环链表的头结点handler和要删除的结点p
</code></pre>
<h1 id="内核链表"><a href="#内核链表" class="headerlink" title="内核链表"></a>内核链表</h1><pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/usr/src/linux-hwe<span class="number">-5.4</span>-headers<span class="number">-5.4</span><span class="number">.0</span><span class="number">-122</span>/include/linux</span><br><span class="line"><span class="built_in">list</span>.h</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">prev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_HEAD(name) \</span></span><br><span class="line"><span class="meta">    struct list_head name = LIST_HEAD_INIT(name)</span></span><br><span class="line"></span><br><span class="line">LIST_HEAD(handler);</span><br></pre></td></tr></table></figure>
替换成
struct list_head handler = &#123;&amp;handler, &amp;handler&#125;;

==============================
作业
1.把今天讲过的内容完完整整的复习一遍
2.把使用内核链表的功能补充完整
3.把早测的内容在电脑上写一遍
4.刷题
5.写项目
==============================
</code></pre>
<h2 id="test-c"><a href="#test-c" class="headerlink" title="test.c"></a>test.c</h2><pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">prev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="type">int</span> math;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&amp;s = %p\n&quot;</span>, &amp;s);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&amp;s.id = %p\n&quot;</span>, &amp;s.id);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;s.name = %p\n&quot;</span>, s.name);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&amp;s.math = %p\n&quot;</span>, &amp;s.math);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&amp;s.node = %p\n&quot;</span>, &amp;s.node);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;SIZE=%ld\n&quot;</span>, (<span class="type">size_t</span>)&amp;(((<span class="keyword">struct</span> stu *)<span class="number">0</span>)-&gt;node));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	struct stu a = 0;//假如说a的地址是0x12345678</span></span><br><span class="line"><span class="comment">	struct stu *p = &amp;a;//p 保存的地址是0x12345678</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	p-&gt;node</span></span><br><span class="line"><span class="comment">	(size_t)&amp;((struct stu *)(0)-&gt;node)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</code></pre>
<h1 id="kernellist"><a href="#kernellist" class="headerlink" title="kernellist"></a>kernellist</h1><h2 id="list-h"><a href="#list-h" class="headerlink" title="list.h"></a>list.h</h2><pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _MYTEST_LIST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _MYTEST_LIST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) (&#123;			\</span></span><br><span class="line"><span class="meta">	const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);	\</span></span><br><span class="line"><span class="meta">	(type *)( (char *)__mptr - offsetof(type,member) );&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">prev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span></span><br><span class="line"><span class="comment">//struct list_head name = &#123;&amp;name, &amp;name&#125;;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_HEAD(name) \</span></span><br><span class="line"><span class="meta">	struct list_head name = LIST_HEAD_INIT(name)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">INIT_LIST_HEAD</span><span class="params">(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span>-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">	<span class="built_in">list</span>-&gt;prev = <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __list_add(<span class="keyword">struct</span> list_head *new,</span><br><span class="line">			      <span class="keyword">struct</span> list_head *prev,</span><br><span class="line">			      <span class="keyword">struct</span> list_head *next)</span><br><span class="line">&#123;</span><br><span class="line">	next-&gt;prev = new;</span><br><span class="line">	new-&gt;next = next;</span><br><span class="line">	new-&gt;prev = prev;</span><br><span class="line">	prev-&gt;next = new;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_add</span><span class="params">(<span class="keyword">struct</span> list_head *new, <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line">	__list_add(new, head, head-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_add_tail</span><span class="params">(<span class="keyword">struct</span> list_head *new, <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line">	__list_add(new, head-&gt;prev, head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __list_del(<span class="keyword">struct</span> list_head * prev, <span class="keyword">struct</span> list_head * next)</span><br><span class="line">&#123;</span><br><span class="line">	next-&gt;prev = prev;</span><br><span class="line">	prev-&gt;next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_del</span><span class="params">(<span class="keyword">struct</span> list_head *entry)</span></span><br><span class="line">&#123;</span><br><span class="line">	__list_del(entry-&gt;prev, entry-&gt;next);</span><br><span class="line">	entry-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	entry-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">	container_of(ptr, type, member)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_for_each(pos, head) \</span></span><br><span class="line"><span class="meta">	for (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	list_for_each(pos, head)</span></span><br><span class="line"><span class="comment">		遍历链表</span></span><br><span class="line"><span class="comment">		pos		指向每个数据节点的node</span></span><br><span class="line"><span class="comment">		head	指向头节点的指针</span></span><br><span class="line"><span class="comment">	list_entry(ptr, type, member)</span></span><br><span class="line"><span class="comment">		得到数据的首地址	</span></span><br><span class="line"><span class="comment">		ptr		node的地址</span></span><br><span class="line"><span class="comment">		type	客户的结构体名</span></span><br><span class="line"><span class="comment">		member	结构体中node的成员名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="kernellist-c"><a href="#kernellist-c" class="headerlink" title="kernellist.c"></a>kernellist.c</h2><pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	内核链表</span></span><br><span class="line"><span class="comment">		有头双向循环链表</span></span><br><span class="line"><span class="comment">		1.创建头结点</span></span><br><span class="line"><span class="comment">		2.插入数据结点(头插法 尾插法)</span></span><br><span class="line"><span class="comment">		3.遍历链表</span></span><br><span class="line"><span class="comment">		4.销毁链表</span></span><br><span class="line"><span class="comment">		==================</span></span><br><span class="line"><span class="comment">		5.查找结点</span></span><br><span class="line"><span class="comment">		6.删除结点</span></span><br><span class="line"><span class="comment">		7.拿出结点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;list.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAMESIZE 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="type">char</span> name[NAMESIZE];</span><br><span class="line">	<span class="type">int</span> math;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">&#125;STU;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> STU *p = data;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d	%s	%d\n&quot;</span>, p-&gt;id, p-&gt;name, p-&gt;math);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">id_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *data, <span class="type">const</span> <span class="type">void</span> *key)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> STU *p = data;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> *k = key;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> !(p-&gt;id - *k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">name_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *data, <span class="type">const</span> <span class="type">void</span> *key)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> STU *p = data;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *k = key;</span><br><span class="line">	<span class="keyword">return</span> !(<span class="built_in">strcmp</span>(p-&gt;name, k));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	LIST_HEAD(handler);<span class="comment">//创建头结点</span></span><br><span class="line">	STU *data = <span class="literal">NULL</span>;<span class="comment">//将来指向开辟的空间,存储数据</span></span><br><span class="line">	STU *datap = <span class="literal">NULL</span>;<span class="comment">//将来指向数据结点的首地址</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">pos</span> =</span> <span class="literal">NULL</span>;<span class="comment">//pos指针指向每个数据结点</span></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;<span class="comment">//循环变量</span></span><br><span class="line">	<span class="type">int</span> find_id = <span class="number">100</span>;<span class="comment">//要查找的ID号</span></span><br><span class="line">	<span class="type">char</span> *find_name = <span class="string">&quot;stu4&quot;</span>;<span class="comment">//要查找的名字</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(STU));<span class="comment">//开辟空间</span></span><br><span class="line">		<span class="keyword">if</span>(data == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		data-&gt;id = <span class="number">100</span> + i;</span><br><span class="line">		<span class="built_in">sprintf</span>(data-&gt;name, <span class="string">&quot;stu%d&quot;</span>, i);</span><br><span class="line">		data-&gt;math = <span class="number">100</span> - i;</span><br><span class="line">		<span class="comment">//list_add(&amp;data-&gt;node, &amp;handler);//头插法</span></span><br><span class="line">		list_add_tail(&amp;data-&gt;node, &amp;handler);<span class="comment">//尾插法</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//不要加 ; 因为list_for_each是一个宏</span></span><br><span class="line">	list_for_each(pos, &amp;handler)<span class="comment">//遍历链表</span></span><br><span class="line">	&#123;</span><br><span class="line">		datap = list_entry(pos, STU, node);</span><br><span class="line">		<span class="comment">//获取数据结点的首地址</span></span><br><span class="line">		print(datap);<span class="comment">//打印数据</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;----------------------\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	list_for_each(pos, &amp;handler)<span class="comment">//查找结点</span></span><br><span class="line">	&#123;</span><br><span class="line">		datap = list_entry(pos, STU, node);</span><br><span class="line">		<span class="keyword">if</span>(name_cmp(datap, <span class="string">&quot;stu9&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Find It!\n&quot;</span>);</span><br><span class="line">			print(datap);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;----------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	list_for_each(pos, &amp;handler)<span class="comment">//销毁链表</span></span><br><span class="line">	&#123;</span><br><span class="line">		datap = list_entry(pos, STU, node);<span class="comment">//找到首地址</span></span><br><span class="line">		list_del(pos);<span class="comment">//把数据结点从链表摘除</span></span><br><span class="line">		<span class="built_in">free</span>(datap);<span class="comment">//释放空间</span></span><br><span class="line">		pos = &amp;handler;<span class="comment">//指向头结点</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="naoemb"
      src="/images/%E5%BE%AE%E4%BF%A1%E5%A4%B4%E5%83%8F.jpg">
  <p class="site-author-name" itemprop="name">naoemb</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">65</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hexgio" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hexgio" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hexgio@outlook.com" title="E-Mail → mailto:hexgio@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/hexgio" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;hexgio" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://ynblog.cf/" title="关联博客 → https:&#x2F;&#x2F;ynblog.cf" rel="noopener" target="_blank"><i class=" fa-fw"></i>关联博客</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">naoemb</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">355k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:22</span>
</div>




















<span id="sitetime"></span>
<script language=javascript>
	function siteTime(){
		window.setTimeout("siteTime()", 1000);
		var seconds = 1000;
		var minutes = seconds * 60;
		var hours = minutes * 60;
		var days = hours * 24;
		var years = days * 365;
		var today = new Date();
		var todayYear = today.getFullYear();
		var todayMonth = today.getMonth()+1;
		var todayDate = today.getDate();
		var todayHour = today.getHours();
		var todayMinute = today.getMinutes();
		var todaySecond = today.getSeconds();
		/* 
		Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
		year - 作为date对象的年份，为4位年份值
		month - 0-11之间的整数，做为date对象的月份
		day - 1-31之间的整数，做为date对象的天数
		hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
		minutes - 0-59之间的整数，做为date对象的分钟数
		seconds - 0-59之间的整数，做为date对象的秒数
		microseconds - 0-999之间的整数，做为date对象的毫秒数
        */
		var t1 = Date.UTC(2020,02,13,15,00,00); //北京时间2018-2-13 00:00:00
		var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
		var diff = t2-t1;
		var diffYears = Math.floor(diff/years);
		var diffDays = Math.floor((diff/days)-diffYears*365);
		var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
		var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
		var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
		document.getElementById("sitetime").innerHTML=" 已运行"+/*diffYears+" 年 "+*/diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
	}
	siteTime();
</script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
